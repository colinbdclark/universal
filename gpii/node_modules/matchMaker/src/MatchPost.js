/*!
GPII Match Maker POST Handler

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        request = fluid.registerNamespace("gpii.request.matchMaker"),
        kettle = fluid.require("kettle", require);

    // TODO: Cut and pasted from FlowManagerUtilities.js
    // Move this into a base library for all GPII components.
    request.log = function (msg, data) {
        data = data || "";
        data = fluid.isPrimitive(data) ? data : fluid.prettyPrintJSON(data, {
            indent: 2
        });

        fluid.log(fluid.logLevel.IMPORTANT, "\n", msg, data,  "\n\n--------------------\n");
    };

    request.match = function (matchMaker, when, solutions, preferences) {
        var transform = matchMaker.transformer.transformSettings,
            strategy = fluid.getGlobalValue(matchMaker.options.strategy);

        var humanReadableMatchMakerType = fluid.pathUtil.getToTailPath(matchMaker.options.strategy);
        request.log("Requesting a match from the", humanReadableMatchMakerType +  "Matchmaker strategy.");

        when(matchMaker.match(preferences, solutions, strategy), function (matchedSolutions) {
            var matchedSolutionsSummary = fluid.transform(matchedSolutions, function (solutionSpec) {
                return solutionSpec.id;
            });

            request.log("The Matchmaker strategy returned a list of solutions to configure:\n", matchedSolutionsSummary);
            request.log("Transforming common terms into application-specific preferences using the Transformer.");

            var transformed = transform({
                solutions: matchedSolutions,
                preferences: preferences
            });

            var transformedSettingsSummary = fluid.transform(transformed, function (solutionSpec) {
                var togo = {};
                var settingsHandlerSummaries = fluid.transform(solutionSpec.settingsHandlers, function (settingsHandlerSpec) {
                    var shSummary = {};
                    shSummary[settingsHandlerSpec.type] = settingsHandlerSpec.settings;

                    return shSummary;
                });

                togo[solutionSpec.id] = settingsHandlerSummaries;

                return togo;
            });

            request.log("Transformed settings:", transformedSettingsSummary);
            
            return transformed;
        });
    };

    request.getSolutions = function (matchMaker, event, model) {
        var device = model.device,
            os = fluid.get(device, "OS.id"),
            version = fluid.get(device, "OS.version");

        request.log("Requesting solutions information from the Solutions Registry appropriate for this device:\n", device);

        matchMaker.solutionsReporter.get({
            os: os,
            version: version
        }, function (solutions) {
            matchMaker.prefilterSolutions(solutions, os, version);
            solutions = matchMaker.prefilterSolutions(solutions, device);

            var solutionSummary = fluid.transform(solutions, function (solutionSpec) {
                return solutionSpec.name;
            });

            request.log("The Solutions Registry returned a list of all device-appropriate solutions, including:\n",
                solutionSummary);
            event.fire(solutions);
        });
    };

    request.transformPreferences = function (matchMaker, event, model) {
        var ontologyServerURL = matchMaker.ontologyServer.ontologySource.urlResolver.resolve();
        request.log("Requesting an ontological transformation from the Ontology Server at:\n     ", ontologyServerURL);

        matchMaker.ontologyServer.set(null, {
            preferences: model.preferences
        }, function (preferences) {
            request.log("The Ontology Server categorized the N&P set into the structure requested by the Matchmaker:\n",
                preferences);
            event.fire(preferences);
        });
    };

    request.matchPost = function (that, model) {
        request.log("The Matchmaker Server recieved a request to match a preference set with the available solutions.");
        that.events.onMatchRequest.fire(model);
    };

    fluid.defaults("kettle.requests.request.handler.matchPost", {
        gradeNames: ["autoInit", "fluid.eventedComponent"],
        components: {
            "matchMaker": "{gpii.matchMaker}"
        },
        invokers: {
            handle: {
                funcName: "gpii.request.matchMaker.matchPost",
                args: ["{that}", "{request}.req.body"],
                dynamic: true
            },
            match: {
                funcName: "gpii.request.matchMaker.match",
                args: ["{gpii.matchMaker}", "{that}.when", "{arguments}.0", "{arguments}.1"]
            },
            getSolutions: {
                funcName: "gpii.request.matchMaker.getSolutions",
                args: ["{gpii.matchMaker}", "{that}.events.onSolutionsReporter", "{arguments}.0"]
            },
            transformPreferences: {
                funcName: "gpii.request.matchMaker.transformPreferences",
                args: ["{gpii.matchMaker}", "{that}.events.onOntologyServer", "{arguments}.0"]
            }
        },
        events: {
            onMatchRequest: null,
            onSolutionsReporter: null,
            onOntologyServer: null,
            onReadyToMatch: {
                events: {
                   solutions: "onSolutionsReporter",
                   ontology: "onOntologyServer"
                },
                args: ["{arguments}.solutions.0", "{arguments}.ontology.0"]
            }
        },
        listeners: {
            onMatchRequest: [{
                listener: "{that}.getSolutions"
            }, {
                listener: "{that}.transformPreferences"
            }],
            onReadyToMatch: "{that}.match"
        }
    });

    fluid.defaults("kettle.requests.request.handler.proxyMatchPost", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            handle: {
                funcName: "gpii.request.matchMaker.proxyMatchPost",
                args: [
                    "{requestProxy}",
                    "{request}.req.body",
                    "{gpii.matchMakerProxy}.matchMakerSource",
                    "{gpii.matchMakerProxy}.options.matchMakerPathMap"
                ],
                dynamic: true
            }
        }
    });

    request.proxyMatchPost = function (requestProxy, model, matchMakerSource, matchMakerPathMap) {
        var matchMakerType;
        fluid.remove_if(model.preferences, function (pref, key) {
            if (key.indexOf("matchMakerType") > -1) {
                matchMakerType = pref[0].value;
                return matchMakerType;
            }
        });
        matchMakerSource.set({
            matchMakerPath: matchMakerPathMap[matchMakerType || "flat"]
        }, model, requestProxy.events.onSuccess.fire);
    };

})();
